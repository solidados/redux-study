## Создание логики `Action`
7. После создания функции `reducer`, в нём необходимо будет производить какую-то логику.  
   Вся логика фокусируется на том, какой `action`
   был проброшен в функцию.

8. Поэтому создаём конструкцию `switch..case`, в которой будем отслеживать `action.type` (тип проброшенного `action`).  
   По дефолту, эта
   конструкция **должна** возвращать состояние `state`.  
   То есть, если пришёл `action.type`, который не обрабатывается ни в одном из `case`, то будет возвращаться неизменённое состояние.
9. `state` – это некий объект, или массив, или даже может быть примитивное значение, которое хранит какие-то данные.  
   Можно создать
   дефолтное состояние, например `initState`, которое будет отображаться, когда пользователь открыл приложение.  
   И каждый раз, когда мы будем в `dispatch` прокидывать какой-то `action`, `state` будет изменяться и храниться в `store` до тех пор, пока
   пользователь либо не обновит страницу, либо не закроет приложение.
10. Далее, для каждого `action` создаётся свой `case`, и после того, как мы в `dispatch` пробрасываем `action`, он попадает в `reducer`,
    и в зависимости от типа, который был указан в `action`, отрабатывает тот или иной `case`.
